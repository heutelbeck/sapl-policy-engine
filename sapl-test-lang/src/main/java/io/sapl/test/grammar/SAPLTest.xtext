grammar io.sapl.test.^grammar.SAPLTest with org.eclipse.xtext.common.Terminals

generate sAPLTest "http://www.sapl.io/test/grammar/SAPLTest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SAPLTest:
    (elements+=TestSuite)*;

terminal JSONNUMBER returns ecore::EBigDecimal: // Definition according to JSON standard  Unary operator for negation/plus prefix
	('0' | ('1'..'9') DIGIT*) ('.' DIGIT+)? (('E' | 'e') ('+' | '-')? DIGIT+)? ;

terminal fragment DIGIT:
	('0'..'9') ;

terminal MultipleAmount:
    (('2'..'9')|(('1'..'9')('0'..'9')+))'x';

PolicyResolverConfig:
    {PoliciesByIdentifier} 'with' 'identifier' identifier=STRING |
    {PoliciesByInputString} policies+=STRING (',' policies+=STRING)+ ('with' 'pdp' 'config' pdpConfig=STRING)?;

CombiningAlgorithm:
	  {DenyOverridesCombiningAlgorithm}     'deny-overrides'
	| {PermitOverridesCombiningAlgorithm}   'permit-overrides'
	| {OnlyOneApplicableCombiningAlgorithm} 'only-one-applicable'
	| {DenyUnlessPermitCombiningAlgorithm}  'deny-unless-permit'
	| {PermitUnlessDenyCombiningAlgorithm}  'permit-unless-deny' ;

JsonArrayMatcher: '[' matchers+=JsonNodeMatcher (',' matchers+=JsonNodeMatcher)* ']';

JsonObjectMatcherPair: key=STRING ':' matcher=JsonNodeMatcher;

JsonObjectMatcher: '{' matchers+=JsonObjectMatcherPair (',' matchers+=JsonObjectMatcherPair)* '}';

JsonNodeMatcher:
    {IsJsonNull} 'null' |
    {IsJsonText} 'text' text=StringOrStringMatcher |
    {IsJsonNumber} 'number' (number=JSONNUMBER)? |
    {IsJsonBoolean} 'boolean' (value=BooleanLiteral)? |
    {IsJsonMissing} 'missing' |
    {IsJsonArray} 'array' ('where' matcher=JsonArrayMatcher)? |
    {IsJsonObject} 'object' ('where' matcher=JsonObjectMatcher)?;

StringMatcher:
    {StringIsNull} 'null' |
    {StringIsBlank} 'blank' |
    {StringIsEmpty} 'empty' |
    {StringIsNullOrEmpty} 'null-or-empty' |
    {StringIsNullOrBlank} 'null-or-blank' |
    {StringIsEqualWithCompressedWhiteSpace} 'equals' value=STRING 'with' 'compressed' 'whitespaces' |
    {StringIsEqualIgnoringCase} 'equals' value=STRING 'ignoring' 'case' |
    {StringMatchesRegex} 'matches' 'regex' regex=STRING |
    {StringStartsWith} 'starts' 'with' start=STRING caseInsensitive?='ignoring case' |
    {StringEndsWith} 'ends' 'with' end=STRING caseInsensitive?='ignoring case' |
    {StringContains} 'contains' value=STRING caseInsensitive?='ignoring case' |
    {StringContainsInOrder} 'contains' substrings+=STRING (',' substrings+=STRING)* 'in' 'order' |
    {StringWithLength} 'has' 'length' 'of' length=JSONNUMBER;

StringOrStringMatcher:
    {PlainString} text=STRING | StringMatcher;

ValMatcher:
    {AnyVal} 'any' |
    {ValWithValue} value=Value |
    {ValWithMatcher} 'matching' matcher=JsonNodeMatcher |
    {ValWithError} 'with' 'error' (error=StringOrStringMatcher)?;

DefaultObjectMatcher:
    {ObjectWithExactMatch} 'equals' object=Value |
    {ObjectWithMatcher} 'matching' matcher=JsonNodeMatcher;

ExtendedObjectMatcher:
    DefaultObjectMatcher |
    {ObjectWithKeyValueMatcher} 'containing' 'key' key=STRING ('value' matcher=JsonNodeMatcher)?;

enum AuthorizationDecisionMatcherType:
    OBLIGATION='obligation' | ADVICE='advice';

enum FunctionLibrary:
	FILTER='FilterFunctionLibrary' | LOGGING='LoggingFunctionLibrary' | STANDARD='StandardFunctionLibrary' | TEMPORAL='TemporalFunctionLibrary';

enum AuthorizationDecisionType:
	PERMIT='permit' | DENY='deny' | INDETERMINATE='indeterminate' | NOT_APPLICABLE='notApplicable';

AuthorizationDecisionMatcher:
    {AnyDecision} 'any' |
    {IsDecision} 'is' decision=AuthorizationDecisionType |
    {HasObligationOrAdvice} 'with' type=AuthorizationDecisionMatcherType (matcher=ExtendedObjectMatcher)? |
    {HasResource} 'with' 'resource' (matcher=DefaultObjectMatcher)?;

FunctionParameters:
    matchers+=ValMatcher (',' matchers+=ValMatcher)*;

FixtureRegistration:
    {Pip} 'PIP' fqn=STRING |
    {CustomFunctionLibrary} 'custom' 'library' fqn=STRING |
    {SaplFunctionLibrary} 'library' library=FunctionLibrary;

AuthorizationSubscription:
	'subject' subject=Value 'attempts' 'action' action=Value 'on' 'resource' resource=Value ('with' 'environment' environment=Value)?;

NumericAmount:
    {Once} 'once' |
    {Multiple} amount=MultipleAmount;

Duration: duration=STRING;

Value:
	Object | Array | NumberLiteral | StringLiteral | BooleanLiteral | NullLiteral | UndefinedLiteral;

Object returns Value:
	{Object} '{' (members+=Pair (',' members+=Pair)*)? '}' ;

Pair:
	key=STRING ':' value=Value;

Array returns Value:
	{Array} '[' (items+=Value (',' items+=Value)*)? ']' ;

BooleanLiteral returns Value:
	  {TrueLiteral} 'true'
	| {FalseLiteral} 'false' ;

StringLiteral returns Value:
	{StringLiteral} string=STRING ;

NumberLiteral returns Value:
	{NumberLiteral} number=JSONNUMBER ;

NullLiteral returns Value:
    {NullLiteral} 'null' ;

UndefinedLiteral returns Value:
    {UndefinedLiteral} 'undefined' ;

GivenStep:
	{Function} 'function' name=STRING ('called with' parameters=FunctionParameters)? 'returning' returnValue=Value ('and' 'is' 'invoked' amount=NumericAmount)? |
	{FunctionInvokedOnce} 'function' name=STRING 'returns' returnValue+=Value (',' returnValue+=Value)* 'once' |
	{Attribute} 'attribute' name=STRING ('returns' returnValue+=Value (',' returnValue+=Value)* ('for' duration=Duration)?)? |
	{AttributeWithParameters} 'attribute' name=STRING 'with' 'parent' 'value' parentMatcher=ValMatcher ('and' 'parameters' parameters+=ValMatcher (',' parameters+=ValMatcher)+)? 'returns' returnValue=Value |
	{VirtualTime} 'virtual-time';

WhenStep:
     'when' authorizationSubscription=AuthorizationSubscription;

ExpectOrAdjustmentStep:
    ExpectStep | AdjustmentStep;

ExpectStep returns ExpectOrAdjustmentStep:
	{Next} 'expect' expectedDecision=AuthorizationDecisionType amount=NumericAmount |
	{NextWithDecision} 'expect' 'decision' expectedDecision=AuthorizationDecision |
	{NextWithMatcher} 'expect' 'decision' matcher+=AuthorizationDecisionMatcher (',' matcher+=AuthorizationDecisionMatcher)* |
	{NoEvent} 'expect' 'no-event' 'for' duration=Duration;

AdjustmentStep returns ExpectOrAdjustmentStep:
    {AttributeAdjustment} 'let' attribute=STRING 'return' returnValue=Value |
	{Await} 'wait' 'for' duration=Duration;

AuthorizationDecision:
    decision=AuthorizationDecisionType ('with' 'obligations' obligations+=Value (',' obligations+=Value)*)? ('with' 'resource' resource=Value)? ('with' 'advice' advice+=Value (',' advice+=Value)*)?;

ExpectChain:
	{SingleExpect} 'expect' 'single' decision=AuthorizationDecision |
	{SingleExpectWithMatcher} 'expect' 'single' 'decision' 'matching' matcher=AuthorizationDecisionMatcher |
	{TestException} 'expect' 'exception' |
	{RepeatedExpect} ('-' expectSteps+=ExpectOrAdjustmentStep)+;

TestCase:
    'scenario' name=STRING ('with' 'environment' environment=Object)? ('register' ('-' registrations+=FixtureRegistration)+)? ('given' ('-' givenSteps+=GivenStep)+)? whenStep=WhenStep 'then' expect=ExpectChain';';

TestSuite:
    UnitTestSuite | IntegrationTestSuite;

UnitTestSuite:
	id=STRING 'tests' '{'
		(testCases+=TestCase)+
	'}';

IntegrationTestSuite:
    'test' 'set' 'of' 'policies' config=PolicyResolverConfig
    ('using variables' pdpVariables=Object)?
    ('using combining-algorithm' combiningAlgorithm=CombiningAlgorithm)?
    '{'
        (testCases+=TestCase)+
    '}';