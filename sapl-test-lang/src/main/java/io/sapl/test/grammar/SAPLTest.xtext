grammar io.sapl.test.^grammar.SAPLTest with org.eclipse.xtext.common.Terminals

generate sAPLTest "http://www.sapl.io/test/grammar/SAPLTest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SAPLTest:
    (elements+=TestSuite)*;

terminal IMPORT_NAME: ('a'..'z')+'.'('a'..'z'|'A'..'Z'|'0'..'9')+;

TestSuite:
	policy=ID 'tests' '{'
		(testCases+=TestCase)+
	'}';

WhenStep:
	 'when' authorizationSubscription=AuthorizationSubscription;

ExpectMatcher:
    {AuthorizationDecisionMatcher} decision=AuthorizationDecision |
    {ObligationMatcher} 'obligation' value=STRING;

ParameterMatcher:
    {Equals} value=Val |
    {Any} 'any';

FunctionParameters:
    matchers+=ParameterMatcher (',' matchers+=ParameterMatcher)*;

Val:
    {IntVal} value=INT |
    {StringVal} value=STRING |
    {BoolVal} (isTrue?='true' | 'false');

GivenStep:
	{Function} 'function' importName=IMPORT_NAME ('called with' parameters=FunctionParameters)? 'returns' returnValue=Val ('and' 'is' 'invoked' amount=NumericAmount)? |
	{FunctionInvokedOnce} 'function' importName=IMPORT_NAME 'returns' return+=Val (',' return+=Val)* 'once' |
	{Attribute} 'attribute' importName=IMPORT_NAME ('returns' return+=Val (',' return+=Val)* ('for' amount=TemporalAmount)?)? |
	{AttributeWithParameters} 'attribute' importName=IMPORT_NAME 'with' 'parent' 'value' parentMatcher=ParameterMatcher ('and' 'parameters' parameters+=Val (',' parameters+=Val)+)? 'returns' return=Val |
	{VirtualTime} 'virtualTime' |
    {Pip} 'PIP' pip=ID |
    {Library} 'functionLibrary' library=FunctionLibrary |
    {Variable} 'variable' 'key' key=ID 'value' value=ID;

FunctionLibrary:
	'FilterFunctionLibrary'|'LoggingFunctionLibrary'|'StandardFunctionLibrary'|'TemporalFunctionLibrary';

AuthorizationDecision:
	'permit'|'deny'|'indeterminate'|'notApplicable';

AuthorizationSubscriptionElement:
    {Plain} value=ID |
    {Structured} elements+=JsonElement (',' elements+=JsonElement)*;

AuthorizationSubscription:
	subject=AuthorizationSubscriptionElement 'attempts' action=AuthorizationSubscriptionElement 'on' resource=AuthorizationSubscriptionElement;

NumericAmount:
    {Once} 'once' |
    {Multiple} amount=INT 'times';

TemporalAmount: seconds=INT's';

ExpectOrAdjustmentStep:
    ExpectStep | AdjustmentStep;

ExpectStep returns ExpectOrAdjustmentStep:
	{Next} 'expect' expectedDecision=AuthorizationDecision amount=NumericAmount |
	{NextWithMatcher} 'expect' 'decision' 'matching' matcher+=ExpectMatcher (',' matcher+=ExpectMatcher)* |
	{NoEvent} 'no event for' duration=INT 'seconds';

AdjustmentStep returns ExpectOrAdjustmentStep:
    {AttributeAdjustment} 'let' attribute=IMPORT_NAME 'return' returnValue=Val |
	{Await} 'wait' amount=TemporalAmount;

JsonElement:
    'key' key=STRING 'value' value=STRING;

ExpectChain:
	{SingleExpect} 'expect' 'single' decision=AuthorizationDecision ('with' 'obligation' obligationElements+=JsonElement (',' obligationElements+=JsonElement)*)? ('with' 'resource' resourceElements+=JsonElement (',' resourceElements+=JsonElement)*)?|
	{TestException} 'expect' 'exception' |
	{RepeatedExpect} expectSteps+=ExpectOrAdjustmentStep ('then' expectSteps+=ExpectOrAdjustmentStep)*;

TestCase:
	'scenario' name=STRING ('given' givenSteps+=GivenStep ('and' givenSteps+=GivenStep)*)? whenStep=WhenStep 'then' expect=ExpectChain';';



