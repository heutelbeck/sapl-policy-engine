grammar io.sapl.test.^grammar.SAPLTest with org.eclipse.xtext.common.Terminals

generate sAPLTest "http://www.sapl.io/test/grammar/SAPLTest"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SAPLTest:
    (elements+=TestSuite)*;

terminal IMPORT_NAME: ('a'..'z')+'.'('a'..'z'|'A'..'Z'|'0'..'9')+;

TestSuite:
	policy=ID 'tests' '{'
		(testCases+=TestCase)+
	'}';

WhenStep:
	 'when' authorizationSubscription=AuthorizationSubscription;

FunctionParameterMatcher:
    {Equals} 'is' value=Val |
    {Any} 'any' |
    {UsingVal} 'val' value=INT;

AuthorizationDecisionMatcher:
    {IsPermit} 'permit' |
    {Obligation} 'obligation' value=STRING;

FunctionParameters:
    'matching' matchers+=FunctionParameterMatcher+;

Val:
    {IntVal} value=INT |
    {StringVal} value=STRING |
    {BoolVal} (isTrue?='true' | 'false');

GivenStep:
	{Function} 'function' importName=IMPORT_NAME ('parameters' parameters=FunctionParameters)? 'returns' returnValue=Val ('and' 'is' 'invoked' amount=NumericAmount)? |
	{FunctionInvokedOnce} 'function' importName=IMPORT_NAME ('returns' return+=Val (',' return+=Val)* 'once' |
	{Attribute} 'attribute' importName=IMPORT_NAME ('returns' return+=Val (',' return+=Val)* ('for' amount=TemporalAmount)?)? |
	{VirtualTime} 'virtualTime' |
    {Pip} 'PIP' pip=ID |
    {Library} 'functionLibrary' library=FunctionLibrary |
    {Variable} 'variable' 'key' key=ID 'value' value=ID;

FunctionLibrary:
	'FilterFunctionLibrary'|'LoggingFunctionLibrary'|'StandardFunctionLibrary'|'TemporalFunctionLibrary';

AuthorizationDecision:
	'permit'|'deny'|'indeterminate'|'notApplicable';

AuthorizationSubscription:
	{AuthorizationSubscriptionObject} subject=ID 'attempts' action=ID 'on' resource=ID |
	{JsonString} json=ID;

NumericAmount:
    {Once} 'once' |
    {Multiple} amount=INT 'times';

TemporalAmount: seconds=INT's';

ExpectOrAdjustmentStep:
    ExpectStep | AdjustmentStep;

ExpectStep returns ExpectOrAdjustmentStep:
	{Next} 'expect' expectedDecision=AuthorizationDecision amount=NumericAmount |
	{NextWithMatcher} 'matching' matcher+=AuthorizationDecisionMatcher+ |
	{NoEvent} 'no event for' duration=INT 'seconds';

AdjustmentStep returns ExpectOrAdjustmentStep:
    {AttributeAdjustment} 'let' attribute=IMPORT_NAME 'return' returnValue=Val |
	{Await} 'wait' amount=TemporalAmount;

ExpectChain:
	{SingleExpect} 'expect''single' decision=AuthorizationDecision |
	{RepeatedExpect} expectSteps+=ExpectOrAdjustmentStep ('then' expectSteps+=ExpectOrAdjustmentStep)*;

TestCase:
	'scenario' name=STRING ('given' givenSteps+=GivenStep ('and' givenSteps+=GivenStep)*)? whenStep=WhenStep 'then' expect=ExpectChain';';



