name: Release SAPL Server LT
on: workflow_dispatch 

permissions:
  contents: read

env:
  # Use docker.io for Docker Hub if empty
  REGISTRY: ghcr.io
  # github.repository as <account>/<repo>
  IMAGE_NAME: ${{ github.actor }}/sapl-server-lt 

jobs:
  # Job to build artifact
  build:
    name: Build and release artifact
    runs-on: ubuntu-latest
    permissions:
      actions: read # To read the workflow path
      packages: write
    outputs:
      # Hash of the artifact
      hashes: ${{ steps.hash.outputs.hashes }}
      docker-digest: ${{ steps.build.outputs.IMAGE_DIGEST }}
      docker-version: ${{ steps.build.outputs.IMAGE_VERSION }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
        with:
          egress-policy: audit

      - name: Check out
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
        with:
            lfs: true
            fetch-depth: 0
      # Set up BuildKit Docker container builder to be able to build
      # multi-platform images and export cache
      # https://github.com/docker/setup-buildx-action
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@f95db51fddba0c2d1ec667646a06c2ce06100226 # v3.0.0

      - name: Set up JDK 21
        uses: actions/setup-java@387ac29b308b003ca37ba93a6cab5eb57c8f5f93 # v4.0.0
        with:
          distribution: 'temurin'
          java-version: 21
          cache: 'maven'

      - name: Setup Maven
        uses: stCarolas/setup-maven@d6af6abeda15e98926a57b5aa970a96bb37f97d1 # v5
        with:
          maven-version: 3.9.6

      # Login against a Docker registry except on PR
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Import the GPG key and make it available
      - name: Install GPG Code Signing Key
        run: |
          cat <(echo -e "${{ secrets.OSSRH_GPG_SECRET_KEY }}") | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG
      
#region CERTSTORE SETUP FOR JARSIGNER
      # Requires base64 encoded certificate and relating password
      - name: Import certificate into Java keystore
        run: |
          echo "${{ secrets.JARSIGNER_CERTIFICATE_BASE64 }}" | base64 --decode > cert.crt
          keytool -import -alias myalias -file cert.crt -storepass ${{ secrets.JARSIGNER_CERTIFICATE_PASSWORD }} -noprompt
#endregion

      # Build artifact
      - name: Build sapl-server-lt
        id: build
        env:
          # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE: ${{ env.IMAGE_NAME }}
        run: |
          #region DEFAULT BUILD
          mvn -B --no-transfer-progress -Dgpg.passphrase=${{ secrets.OSSRH_GPG_SECRET_KEY_PASSWORD }} -pl sapl-server-lt -am -Ppublish -DskipTests clean package deploy
          #endregion

          #region JARSIGNER BUILD
          # mvn -B --no-transfer-progress -Dgpg.passphrase=${{ secrets.OSSRH_GPG_SECRET_KEY_PASSWORD }} -Djarsigner.alias="myalias" -Djarsigner.storepass="${{ secrets.JARSIGNER_CERTIFICATE_PASSWORD }}" -pl sapl-server-lt -am -Ppublish -DskipTests clean package deploy
          #endregion
          
          # Save the location of the maven output files for easier reference
          ARTIFACT_PATTERN=sapl-server-lt/target/sapl-server-lt-*.jar
          echo "artifact_pattern=$ARTIFACT_PATTERN" >> "$GITHUB_OUTPUT"

          # Save the digest of the Docker image for later use
          IMAGE_DIGEST=$(docker inspect ${REGISTRY}/${IMAGE} --format '{{.RepoDigests}}' | sed -e 's/^.*@//' -e 's/]$//')
          echo "Digest of container" + $IMAGE_DIGEST
          echo "IMAGE_DIGEST=$IMAGE_DIGEST" >> $GITHUB_OUTPUT

          # Save the version of the Docker image for later use
          IMAGE_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "Version of container" + $IMAGE_VERSION
          echo "IMAGE_VERSION=$IMAGE_VERSION" >> $GITHUB_OUTPUT

          
       # Generate hashes of the artifact
      - name: Generate subject
        id: hash
        run: |
          echo "hashes=$(sha256sum ${{ steps.build.outputs.artifact_pattern }} | base64 -w0)" >> "$GITHUB_OUTPUT"

      # Upload the artifact and additional files
      - name: Upload artifact and signature
        uses: actions/upload-artifact@a8a3f3ad30e3422c9c7b888a15615d19a852ae32 # v3.1.3 
        with:
          if-no-files-found: error 
          path: |
            sapl-server-lt/target/sapl-server-lt-*.jar
            sapl-server-lt/target/sapl-server-lt-*.jar.asc
            sapl-server-lt/target/sapl-server-lt-*.jar.sha1
            sapl-server-lt/target/sapl-server-lt-*.jar.md5
            sapl-server-lt/target/site/io.*.spdx.json

  # Create provenance for the artifact
  provenance:
    needs: [ build ]
    permissions:
      actions: read # To read the workflow path
      id-token: write # To sign the provenance
      contents: write # To add assets to a release
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.9.0
    with:
      base64-subjects: ${{ needs.build.outputs.hashes }}
      upload-assets: true # Optional: Upload to a new release

  # Verify the provenance of artifact
  verify:
    needs: [ build, provenance ]
    runs-on: ubuntu-latest
    permissions:
      actions: read # To read the workflow path
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
        with:
          egress-policy: audit

      - uses: slsa-framework/slsa-verifier/actions/installer@7e1e47d7d793930ab0082c15c2b971fdb53a3c95  # v2.4.1

      - name: Download the artifact
        uses: actions/download-artifact@9bc31d5ccc31df68ecc42ccf4149144866c47d8a # v3.0.2

      # SLSA provenance verification using slsa-verifier
      - name: Verify SLSA Provenance (slsa-verifier)
        run: |
          slsa-verifier verify-artifact ./**/sapl-server-lt*.jar  --source-uri "github.com/$GITHUB_REPOSITORY" --provenance-path "./${{ needs.provenance.outputs.provenance-name}}/${{ needs.provenance.outputs.provenance-name}}"

  docker:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      actions: read
      packages: write
    steps:

      # Install the cosign tool except on PR
      # https://github.com/sigstore/cosign-installer
      - name: Harden Runner
        uses: step-security/harden-runner@63c24ba6bd7ba022e95695ff85de572c04a18142 # v2.7.0
        with:
          egress-policy: audit

      - name: Install cosign
        uses: sigstore/cosign-installer@e1523de7571e31dbe865fd2e80c5c7c23ae71eb4 # v3.4.0
        with:
          cosign-release: 'v2.2.3'


      
      # Login against a Docker registry except on PR
      # https://github.com/docker/login-action
      - name: Log into registry ${{ env.REGISTRY }}
        uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
# region KEYLESS SIGNING OF THE DOCKER IMAGE USING COSIGN
      
      # # Sign the resulting Docker image digest.
      # # This will only write to the public Rekor transparency log when the Docker
      # # repository is public to avoid leaking data.  If you would like to publish
      # # transparency data even for private images, pass --force to cosign below.
      # # https://github.com/sigstore/cosign
      # - name: Sign the published Docker image
      #   # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
      #   env:
      #     # The image name and digest are passed from the build job
      #     TAGS: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.docker-version }}
      #     DIGEST: ${{ needs.build.outputs.docker-digest }}
      #   # This step uses the identity token to provision an ephemeral certificate
      #   # against the sigstore community Fulcio instance.
      #   run: echo "${TAGS}" | xargs -I {} cosign sign --yes {}@${DIGEST}
      
      # - name: Verify docker image signature
      #   env:
      #     TAGS: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.docker-version }} 
      #   run: | 
      #     cosign verify ${TAGS} \
      #      --certificate-oidc-issuer=https://github.com/login/oauth \
      #      --certificate-identity=account+github@flodet.me
#endregion

# region CERTIFICATE-BASED SIGNING OF THE DOCKER IMAGE USING COSIGN

      # TUTORIAL: https://dev.to/n3wt0n/sign-your-container-images-with-cosign-github-actions-and-github-container-registry-3mni
      # Write the private key to disk to be accessible by the cosign tool
      # Can be generated with `cosign generate-key-pair`
      - name: Write signing cosign key to disk
        env:
          # Generate private key of cosign certificate
          KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}    
        run: echo "${KEY}" > cosign.key


      # Sign the resulting Docker image digest.
      # This will only write to the public Rekor transparency log when the Docker
      # repository is public to avoid leaking data.  If you would like to publish
      # transparency data even for private images, pass --force to cosign below.
      # https://github.com/sigstore/cosign
      - name: Sign the published Docker image
        # https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
        env:
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          # The image name and digest are passed from the build job
          TAGS: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.docker-version }}
          DIGEST: ${{ needs.build.outputs.docker-digest }}
        # This step uses the identity token to provision an ephemeral certificate
        # against the sigstore community Fulcio instance.
        run: cosign sign --key cosign.key --yes ${TAGS}


      # Write the private key to disk to be accessible by the cosign tool
      # Can be generated with `cosign generate-key-pair`
      - name: Write public cosign key to disk
        env:
          # Generate private key of cosign certificate
          KEY: ${{ secrets.COSIGN_PUBLIC_KEY }}
        run: echo "${KEY}" > cosign.pub
        

      - name: Verify docker image signature
        run: | 
          cosign verify  ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.docker-version }} \
           --key cosign.pub
#endregion