/*
 * Copyright (C) 2017-2023 Dominic Heutelbeck (dominic@heutelbeck.com)
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
grammar io.sapl.^grammar.SAPL with org.eclipse.xtext.common.Terminals
hidden(ML_COMMENT, SL_COMMENT, WS)

import "https://sapl.io/sapl/SAPL"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SAPL: 
	imports+=Import*
	schemas+=Schema* policyElement=PolicyElement ;

Import:
	'import' ( {WildcardImport} libSteps+=SaplID ('.' libSteps+=SaplID)* '.' '*'
		     | {LibraryImport} (libSteps+=SaplID '.')* libSteps+=SaplID 'as' libAlias=SaplID
		     | libSteps+=SaplID ('.' libSteps+=SaplID)* '.' functionName=SaplID	) ;

Schema:
    subscriptionElement=ReservedID 'schema' schemaExpression=Expression;

PolicyElement:
	PolicySet | Policy;
	
PolicySet:
	{PolicySet} 'set' saplName=STRING
	algorithm=CombiningAlgorithm ('for' targetExpression=Expression)?
	(valueDefinitions+=ValueDefinition ';')*
	policies+=Policy+ ;

CombiningAlgorithm:
	  {DenyOverridesCombiningAlgorithm}     'deny-overrides' 
	| {PermitOverridesCombiningAlgorithm}   'permit-overrides' 
	| {FirstApplicableCombiningAlgorithm}   'first-applicable' 
	| {OnlyOneApplicableCombiningAlgorithm} 'only-one-applicable'
	| {DenyUnlessPermitCombiningAlgorithm}  'deny-unless-permit' 
	| {PermitUnlessDenyCombiningAlgorithm}  'permit-unless-deny' ;

Policy:
	{Policy} 'policy' saplName=STRING
	entitlement=Entitlement (targetExpression=Expression)?
	(body=PolicyBody)?
	('obligation' obligations+=Expression)*
	('advice' advice+=Expression)*
	('transform' transformation=Expression)?;

Entitlement:	
	  {Permit} 'permit' 
	| {Deny}   'deny';

PolicyBody:
	'where' (statements+=Statement ';')+ ;

Statement:
	ValueDefinition | 
	{Condition} expression=Expression ;

ValueDefinition:
	'var' name=ID '=' eval=Expression
	('schema' schemaVarExpression+=Expression (',' schemaVarExpression+=Expression)*)? ;

Expression:
	LazyOr ;

LazyOr returns Expression:
	LazyAnd ({Or.left=current} '||' right=LazyAnd)* ;
	
LazyAnd returns Expression:
	EagerOr ({And.left=current} '&&' right=EagerOr)* ;

EagerOr returns Expression:
	ExclusiveOr ({EagerOr.left=current} '|' right=ExclusiveOr)* ;
	
ExclusiveOr returns Expression:
	EagerAnd ({XOr.left=current} '^' right=EagerAnd)* ;

EagerAnd returns Expression:
	Equality ({EagerAnd.left=current} '&' right=Equality)* ;

Equality returns Expression:
	Comparison (( {Equals.left=current} '==' 
	            | {NotEquals.left=current} '!=' 
	            | {Regex.left=current} '=~'	) right=Comparison)? ;

Comparison returns Expression:
	Addition (( {Less.left=current} '<' 
		      | {LessEquals.left=current} '<=' 
		      | {More.left=current} '>'
		      | {MoreEquals.left=current} '>=' 
		      | {ElementOf.left=current} 'in' ) right=Addition)? ;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)* ;

Multiplication returns Expression:
	UnaryExpression (({Multi.left=current} '*' | {Div.left=current} '/' | {Modulo.left=current} '%') right=UnaryExpression)* ;

UnaryExpression returns Expression:
	  {Not} '!' expression=UnaryExpression 
	| {UnaryMinus} '-' expression=UnaryExpression 
	| {UnaryPlus} '+' expression=UnaryExpression 
	| BasicExpression;

BasicExpression returns Expression:
	Basic (FILTER filter=FilterComponent | SUBTEMPLATE subtemplate=BasicExpression)?;

Basic returns BasicExpression:
	  {BasicGroup} '(' expression=Expression ')' steps+=Step* 
	| {BasicValue} value=Value steps+=Step*  
	| {BasicFunction} fsteps+=SaplID ('.' fsteps+=SaplID)*  arguments=Arguments steps+=Step*
	| {BasicEnvironmentAttribute} '<' idSteps+=SaplID ('.' idSteps+=SaplID)* arguments=Arguments? '>' steps+=Step*
	| {BasicEnvironmentHeadAttribute} '|<' idSteps+=SaplID ('.' idSteps+=SaplID)* arguments=Arguments? '>' steps+=Step*
	| {BasicIdentifier} identifier=SaplID steps+=Step*
	| BasicRelative;

BasicRelative:
	{BasicRelative} '@' steps+=Step* ;

Arguments:
	{Arguments} '(' (args+=Expression (',' args+=Expression)*)? ')';

Step:
	'.' ( {KeyStep} id=SaplID
		| {EscapedKeyStep} id=STRING
		| {WildcardStep} '*' 
		| {AttributeFinderStep} '<' idSteps+=SaplID ('.' idSteps+=SaplID)* arguments=Arguments? '>'
		| {HeadAttributeFinderStep} '|<' idSteps+=SaplID ('.' idSteps+=SaplID)* arguments=Arguments? '>' )
	| '[' Subscript ']' 
	| '..' ( {RecursiveKeyStep} (id=SaplID | '[' id=STRING ']' )
		   | {RecursiveWildcardStep} ('*' | '[' '*' ']' ) 
		   | {RecursiveIndexStep} '[' index=SignedNumber ']' ) ;
	
Subscript returns Step:
	  {KeyStep} id=STRING 
	| {WildcardStep} '*' 
	| {IndexStep} index=SignedNumber 
	| {ArraySlicingStep} index=SignedNumber? ':' to=SignedNumber? (':' step=SignedNumber)? 
	| {ExpressionStep} '(' expression=Expression ')' 
	| {ConditionStep} '?' '(' expression=Expression ')' 
	| {IndexUnionStep} indices+=SignedNumber ',' indices+=SignedNumber (',' indices+=SignedNumber)* 
	| {AttributeUnionStep} attributes+=STRING ',' attributes+=STRING (',' attributes+=STRING)* ;

Value:
	Object | Array | NumberLiteral | StringLiteral | BooleanLiteral | NullLiteral | UndefinedLiteral ;

Object returns Value:
	{Object} '{' (members+=Pair (',' members+=Pair)*)? '}' ;

Pair:
	key=STRING ':' value=Expression;

Array returns Value:
	{Array} '[' (items+=Expression (',' items+=Expression)*)? ']' ;

BooleanLiteral returns Value:
	  {TrueLiteral} 'true' 
	| {FalseLiteral} 'false' ;

NullLiteral returns Value:
	{NullLiteral} 'null' ;

UndefinedLiteral returns Value:
	{UndefinedLiteral} 'undefined' ;

StringLiteral returns Value:
	{StringLiteral} string=STRING ;

NumberLiteral returns Value:
	{NumberLiteral} number=JSONNUMBER ;

FilterComponent: 
	  {FilterSimple} each?='each'? fsteps+=SaplID ('.' fsteps+=SaplID)* arguments=Arguments? 
	| {FilterExtended} '{' statements+=FilterStatement (',' statements+=FilterStatement)* '}' ;

FilterStatement:
	each?='each'? target=BasicRelative? ':' fsteps+=SaplID ('.' fsteps+=SaplID)* arguments=Arguments? ;

SignedNumber returns ecore::EBigDecimal: '-'? JSONNUMBER;

SaplID returns ecore::EString:
    ID | ReservedID;

ReservedID returns ecore::EString:
    'subject' | 'action' | 'resource' | 'environment';

@Override
terminal ID: 
	'^'? ('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'_'|'$'|'0'..'9')*;

terminal FILTER:
	'|-' ;
	
terminal SUBTEMPLATE:
	'::' ;

terminal JSONNUMBER returns ecore::EBigDecimal: // Definition according to JSON standard  Unary operator for negation/plus prefix
	('0' | ('1'..'9') DIGIT*) ('.' DIGIT+)? (('E' | 'e') ('+' | '-')? DIGIT+)? ;

terminal fragment DIGIT:
	('0'..'9') ;